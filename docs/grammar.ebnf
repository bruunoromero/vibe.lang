(* Vibe Programming Language Grammar (EBNF) *)
(* Inspired by Elm 0.18 *)

(* ===== Program Structure ===== *)

(* A module declaration is REQUIRED as the first statement in every Vibe file.
   The module name must match the file's path relative to the src directory.
   For example:
   - File src/Main.vibe must have: module Main exposing (..)
   - File src/Data/List.vibe must have: module Data.List exposing (..)
   Missing or mismatched module declarations result in a compile error. *)
Program = ModuleDeclaration, {ImportDeclaration}, {Declaration} ;

ModuleDeclaration = "module", ModuleName, "exposing", Exposing ;

ImportDeclaration = "import", ModuleName, ["as", UpperIdentifier], ["exposing", Exposing] ;

(* Exposing clauses support detailed export specifications for types and protocols *)
(* 
  Examples:
    exposing (..)                           -- expose all
    exposing (foo, bar)                     -- expose specific values
    exposing (Maybe(..), Result(Ok, Err))   -- expose types with constructors
    exposing (Num(..), Eq(==, /=))          -- expose protocols with methods
    exposing ((++), (<|>))                  -- expose operators
    exposing (map, List(..), (>>))          -- mixed exports
*)
Exposing = "(", "..", ")"                   (* expose all *)
         | "(", ExportSpecList, ")" ;       (* expose specific items *)

ExportSpecList = ExportSpec, {",", ExportSpec} ;

ExportSpec = LowerIdentifier                (* value or function *)
           | UpperIdentifier                (* opaque type or protocol without members *)
           | "(", Operator, ")"             (* operator *)
           | UpperIdentifier, "(", "..", ")"  (* type or protocol with all constructors/methods *)
           | UpperIdentifier, "(", MemberList, ")" ; (* type or protocol with specific members *)

MemberList = Member, {",", Member} ;

Member = UpperIdentifier                    (* constructor or method name *)
       | LowerIdentifier                    (* method name *)
       | "(", Operator, ")" ;               (* operator method *)

ModuleName = UpperIdentifier, {".", UpperIdentifier} ;


(* ===== Declarations ===== *)

Declaration = ExternalDeclaration
            | TypeAnnotationDeclaration
            | ValueDeclaration
            | TypeDeclaration
            | TypeAliasDeclaration
            | ProtocolDeclaration
            | ImplementationDeclaration
            | InfixDeclaration ;

ExternalDeclaration = "@", "external", String, String, DeclarationName, ":", TypeExpr ;

TypeAnnotationDeclaration = DeclarationName, ":", TypeExpr ;

(* Function parameters allow restricted patterns for type-safe destructuring.
   Allowed patterns:
     - Variables and wildcards: x, _
     - Tuples: (a, b), (x, y, z)
     - Records: { x, y }, { x = pat }
     - Single-constructor ADTs: Pair a b, JustOneMore x
   
   NOT allowed (use case expressions instead):
     - Multi-constructor ADTs: Just x, Ok value (these can fail at runtime)
     - List patterns: [], [x, y], x :: xs
   
   Examples:
     -- Allowed: single-constructor ADT
     never (JustOneMore nvr) = nvr
     
     -- Allowed: tuple destructuring
     fst (a, b) = a
     
     -- Allowed: record destructuring
     getX { x, y } = x
     
     -- NOT allowed: multi-constructor ADT (Maybe has Just and Nothing)
     -- fromJust (Just x) = x  -- Error! Use case expression instead
*)
ValueDeclaration = DeclarationName, {FunctionParamPattern}, "=", Expr ;

(* Function parameter patterns - restricted subset for type-safe destructuring *)
FunctionParamPattern = VarPattern
                     | WildcardPattern
                     | TuplePattern
                     | RecordPattern
                     | ConstructorPattern ;  (* Only single-constructor ADTs validated in semantics *)

(* Record pattern for destructuring *)
RecordPattern = "{", "}"
              | "{", RecordFieldPattern, {",", RecordFieldPattern}, "}" ;

RecordFieldPattern = LowerIdentifier                          (* shorthand: { x } *)
                   | LowerIdentifier, "=", FunctionParamPattern ; (* with pattern: { x = pat } *)

DeclarationName = LowerIdentifier
                | "(", Operator, ")" ;

(* Infix operator declarations - Elm-style *)
(* infixl = left-associative, infixr = right-associative, infix = non-associative *)
(* Precedence 0-9: higher binds tighter *)
InfixDeclaration = ("infix" | "infixl" | "infixr"), Number, Operator
                 | ("infix" | "infixl" | "infixr"), Number, "(", Operator, ")" ;

(* Type declarations have three forms: *)
(*   1. ADT: type Name params = Constructor1 | Constructor2 *)
(*   2. Opaque: type Name params (no equals sign - for JS interop) *)
TypeDeclaration = "type", UpperIdentifier, {LowerIdentifier}, "=", ConstructorDef, {"|", ConstructorDef} ;

(* Opaque type declarations - abstract types for JS interop *)
OpaqueTypeDeclaration = "type", UpperIdentifier, {LowerIdentifier} ;

ConstructorDef = UpperIdentifier, {TypeTerm} ;

(* Type alias declarations - for both record types and simple type aliases *)
(* Examples: *)
(*   type alias Point = { x : Int, y : Int }  (Record) *)
(*   type alias UserId = Int                   (Simple alias) *)
TypeAliasDeclaration = "type", "alias", UpperIdentifier, {LowerIdentifier}, "=", TypeExpr ;



(* Protocol (type class) declarations *)
(* Methods can be regular identifiers or operators in parentheses *)
(* Protocols may have superclass constraints: protocol Eq a => Ord a where ... *)
ProtocolDeclaration = "protocol", [Constraints, "=>"], UpperIdentifier, {LowerIdentifier}, "where", {MethodSignature} ;

MethodSignature = LowerIdentifier, ":", TypeExpr
                | "(", Operator, ")", ":", TypeExpr ;

(* Implementation (instance) declarations *)
(* Type arguments are optional - zero type args means a nullary protocol implementation *)
ImplementationDeclaration = "implement", [Constraints, "=>"], UpperIdentifier, {TypeTerm}, "where", {MethodImpl} ;

(* Method implementations can be either:
   - Simple expression: `plus = intPlus` (reference to existing function)
   - Inline function: `plus x y = x + y` (with pattern parameters)
   Operators in parentheses: `(+) x y = x + y` *)
MethodImpl = LowerIdentifier, {Pattern}, "=", Expr
           | "(", Operator, ")", {Pattern}, "=", Expr ;

Constraints = Constraint
            | "(", Constraint, {",", Constraint}, ")" ;

Constraint = UpperIdentifier, TypeTerm, {TypeTerm} ;


(* ===== Type Expressions ===== *)

(* Type expressions can have optional constraints *)
TypeExpr = [Constraints, "=>"], TypeExprSimple ;

TypeExprSimple = TypeTerm, ["->", TypeExprSimple] ;

TypeTerm = TypeRef
         | "(", TypeExpr, ")"                (* parenthesized type *)
         | "(", TypeExpr, {",", TypeExpr}, ")" ; (* tuple type *)

TypeRef = Identifier, {TypeArg} ;

TypeArg = Identifier
        | "(", TypeExpr, ")" ;


(* ===== Patterns ===== *)

Pattern = ConsPattern ;

ConsPattern = PrimaryPattern, ["::", ConsPattern] ;  (* right-associative *)

PrimaryPattern = VarPattern
               | WildcardPattern
               | ConstructorPattern
               | TuplePattern
               | ListPattern
               | "(", Pattern, ")" ;

VarPattern = LowerIdentifier ;

WildcardPattern = "_" ;

ConstructorPattern = UpperIdentifier, {PrimaryPattern} ;

TuplePattern = "(", Pattern, {",", Pattern}, ")" ;

ListPattern = "[", "]"                          (* empty list *)
            | "[", Pattern, {",", Pattern}, "]" ;  (* list literal *)


(* ===== Expressions ===== *)

Expr = BinaryExpr ;

BinaryExpr = UnaryExpr, {Operator, UnaryExpr} ;  (* precedence handled at runtime *)

(* Unary expressions: prefix negation with higher precedence than binary operators.
   Only `-` is supported as a unary operator, and only for Int/Float types.
   
   Note: `--` starts a comment, so double negation requires grouping: -(-x)
   
   Examples:
     -x          -- negation of variable
     -10         -- negation of literal
     -(x + 1)    -- negation of grouped expression
     -(-x)       -- double negation (requires grouping)
*)
UnaryExpr = "-", UnaryExpr                      (* unary negation *)
          | Application ;

Application = PrimaryWithAccess, {PrimaryWithAccess} ;  (* function application via juxtaposition *)

PrimaryWithAccess = Primary, {".", LowerIdentifier} ;  (* field access *)

(* Primary expressions include all atomic expressions and grouped expressions.
   
   Operators in parentheses are treated as function references:
     (+)     -- the addition function
     (==)    -- the equality function
     (|>)    -- the pipe operator as a function
   
   This allows operators to be used in prefix form or passed as arguments:
     (+) 1 2         -- equivalent to 1 + 2
     foldr (::) []   -- passing cons operator to foldr
*)
Primary = IfExpr
        | LetInExpr
        | CaseExpr
        | LambdaExpr
        | Variable
        | Literal
        | ListExpr
        | TupleExpr
        | RecordExpr
        | RecordUpdateExpr
        | "(", Operator, ")"                  (* operator as function *)
        | "(", Expr, ")" ;                    (* grouped expression *)

IfExpr = "if", Expr, "then", Expr, "else", Expr ;

LetInExpr = "let", {LetBinding}, "in", Expr ;

LetBinding = ValueDeclaration ;  (* indentation-sensitive *)

CaseExpr = "case", Expr, "of", {CaseBranch} ;

CaseBranch = Pattern, "->", Expr ;  (* indentation-sensitive *)

LambdaExpr = "\", {Pattern}, "->", Expr ;

Variable = LowerIdentifier
         | UpperIdentifier ;

Literal = Number
        | String
        | Char
        | Unit ;

Unit = "(", ")" ;

ListExpr = "[", "]"                          (* empty list *)
         | "[", Expr, "..", Expr, "]"        (* range *)
         | "[", Expr, {",", Expr}, "]" ;     (* list literal *)

TupleExpr = "(", Expr, {",", Expr}, ")" ;    (* requires at least 2 elements *)

RecordExpr = "{", "}"                        (* empty record *)
           | "{", RecordField, {",", RecordField}, "}" ;

RecordUpdateExpr = "{", LowerIdentifier, "|", RecordField, {",", RecordField}, "}" ;

RecordField = LowerIdentifier, "=", Expr ;


(* ===== Lexical Elements ===== *)

Identifier = LowerIdentifier | UpperIdentifier ;

LowerIdentifier = LowerLetter, {Letter | Digit | "_"} ;

UpperIdentifier = UpperLetter, {Letter | Digit | "_"} ;

Operator = OperatorChar, {OperatorChar} ;

OperatorChar = "+" | "-" | "*" | "/" | "=" | "<" | ">" | "!" | "?" | ":" | "&" | "|" | "%" | "^" | "~" | "@" | "#" | "$" | "." ;

Number = Digit, {Digit}, [".", Digit, {Digit}] ;

String = '"', {StringChar}, '"' ;

StringChar = ? any character except '"' and '\' ? | EscapeSequence ;

Char = "'", (? any character except "'" and '\' ? | EscapeSequence), "'" ;

EscapeSequence = "\", (? any escape character ?) ;

Letter = LowerLetter | UpperLetter ;

LowerLetter = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m"
            | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" ;

UpperLetter = "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M"
            | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" ;

Digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;


(* ===== Operator Precedence ===== *)

(* 
  Built-in operator precedence levels (0-9, higher binds tighter):
  
  1: |>, <|              (application operators)
  2: ||                  (logical or) - BUILTIN, short-circuit
  3: &&                  (logical and) - BUILTIN, short-circuit
  4: ==, /=, <, <=, >, >= (comparison)
  5: ::, ++              (cons, append) - right associative
  6: +, -                (addition, subtraction)
  7: *, /, //, %         (multiplication, division, modulo)
  8: ^                   (exponentiation) - right associative
  9: <<, >>              (composition) - right associative
  
  Default for unknown operators: 5, left associative
  
  Custom operator precedence can be declared using infix declarations:
    infixl 6 +     -- left-associative at precedence 6
    infixr 5 ++    -- right-associative at precedence 5
    infix 4 ==     -- non-associative at precedence 4
    
  Short-circuit operators (&& and ||) are BUILT INTO THE COMPILER:
    - They cannot be redefined as regular functions
    - They have type: Bool -> Bool -> Bool
    - The second operand is only evaluated if needed:
        False && x  =>  False  (x is not evaluated)
        True || x   =>  True   (x is not evaluated)
    - The compiler wraps the right operand in a thunk during IR lowering
    - Generated JavaScript: (a) => (b) => a && b()  (where b is the thunk)
    
  Other operators can be defined as regular functions:
    (|>) : a -> (a -> b) -> b
    (|>) x f = f x
    
  Operators can also be protocol methods:
    protocol Eq a where
      (==) : a -> a -> bool
      (/=) : a -> a -> bool
*)


(* ===== Layout Rules ===== *)

(*
  Vibe uses significant indentation (layout-sensitive parsing):
  
  1. Let bindings: All bindings must be indented past the "let" keyword
  2. Case branches: All branches must be indented past the "of" keyword
  3. Record fields: Continuation on new lines requires consistent indentation
  4. List/Tuple elements: Continuation on new lines requires consistent indentation
  5. Function application: Arguments on new lines must maintain or increase indentation
  
  Layout rule: A construct continues if the next token is either:
    - On the same line, OR
    - On a new line with column >= base indentation column
*)
