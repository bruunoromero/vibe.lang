module Vibe.List exposing
  ( foldl
  , map
  , filter
  , head
  , tail
  , (::)
  )

import Vibe.String as String
import Vibe.Maybe exposing (Maybe(..))
import Vibe.Basics exposing (Eq(..), Show(..), Appendable(..))

infixr 5 ::

implement Eq a => Eq (List a) where
    (==) xs ys = 
        case (xs, ys) of
            ([], []) -> True
            (x :: xtail, y :: ytail) ->
                x == y && xtail == ytail
            _ -> False

implement Show a => Show (List a) where
    toString lst =
        let 
            elementStrings = map toString lst
        in
            "[" ++ (String.join ", " elementStrings) ++ "]"

implement Appendable (List a) where
    (++) = _append

{-| Constructs a new list by prepending an element to the front of an existing list.

    1 :: [2, 3]  ==  [1, 2, 3]
-}
@external "@vibe/runtime" "listCons"
(::) : a -> List a -> List a

{-| Appends two lists together.

    [1, 2] ++ [3, 4]  ==  [1, 2, 3, 4]
-}
@external "@vibe/runtime" "listAppend"
_append : List a -> List a -> List a


{-| Left fold over a list.

    foldl (+) 0 [1, 2, 3, 4]  ==  10
-}
@external "@vibe/runtime" "listFoldl"
foldl : (b -> a -> b) -> b -> List a -> b

{-| Maps a function over a list.

    map (\x -> x * 2) [1, 2, 3]  ==  [2, 4, 6]
-}
@external "@vibe/runtime" "listMap"
map : (a -> b) -> List a -> List b

{-| Filters a list based on a predicate function.

    filter (\x -> x > 2) [1, 2, 3, 4]  ==  [3, 4]
-}
@external "@vibe/runtime" "listFilter"
filter : (a -> Bool) -> List a -> List a

{-| Returns the first element of a list, or `Nothing` if the list is empty.

    head [1, 2, 3]  ==  Just 1
    head []  ==  Nothing
-}
head : List a -> Maybe a
head xs = 
    case xs of
        x :: _ -> Just x
        [] -> Nothing

{-| Returns the rest of the list after the first element, or `Nothing` if the list is empty.

    tail [1, 2, 3]  ==  Just [2, 3]
    tail []  ==  Nothing
-}
tail : List a -> Maybe (List a)
tail xs = 
    case xs of
        _ :: xtail -> Just xtail
        [] -> Nothing