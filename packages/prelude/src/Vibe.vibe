module Vibe exposing 
    ( (|>)
    , (<|)
    , (>>)
    , (<<)
    , (&&)
    , (||)
    , (::)
    , (++)
    , Maybe(..)
    , Result(..)
    , Pair(..)
    , Num(..)
    , Fractional(..)
    , Integral(..)
    , Eq(..)
    , Ord(..)
    , Show(..)
    , identity
    , always
    , flip
    , apply
    , Never
    )

import Vibe.Int as Int
import Vibe.Float as Float
import Vibe.Bool as Bool
import Vibe.List as List
import Vibe.String as String

type Never = JustOneMore Never

never : Never -> a
never (JustOneMore nvr) = 
    never nvr

{- =============================================================================
   Vibe - The Standard Library for Vibe
   =============================================================================

   This module provides fundamental types, operators, and functions that are
   automatically imported into every Vibe program.

   Contents:
   - Operator fixity declarations
   - Core ADTs (Maybe, Result, List)
   - Numeric protocols and implementations
   - Comparison and equality protocols
   - Logical operators
   - Function composition and application operators
   - Basic utility functions
-}

-- =============================================================================
-- Operator Fixity Declarations
-- =============================================================================
-- These establish precedence and associativity for all standard operators.
-- Higher numbers bind tighter. Range: 1-9.

-- Application operators (lowest precedence)
infixl 1 |>
infixr 1 <|

-- Logical operators
infixr 2 ||
infixr 3 &&

-- Comparison operators
infix 4 ==
infix 4 /=
infix 4 <
infix 4 <=
infix 4 >
infix 4 >=

-- List operators
infixr 5 ::
infixr 5 ++

-- Arithmetic operators
infixl 6 +
infixl 6 -
infixl 7 *
infixl 7 /
infixl 7 //
infixl 7 %
infixr 8 ^

-- Function composition (highest precedence)
infixr 9 <<
infixr 9 >>


-- =============================================================================
-- Core ADTs
-- =============================================================================

{-| Represents an optional value. Used when a value may or may not exist.

    Just x  -- Contains a value x
    Nothing -- No value present

    Example:
        head : List a -> Maybe a
        head list =
            case list of
                x :: _ -> Just x
                [] -> Nothing
-}
type Maybe a
    = Just a
    | Nothing


{-| Represents a computation that can succeed or fail.

    Ok value  -- Success with a value
    Err error -- Failure with an error

    Example:
        divide : Int -> Int -> Result String Int
        divide x y =
            if y == 0 then
                Err "Division by zero"
            else
                Ok (x / y)
-}
type Result error value
    = Ok value
    | Err error


{-| Represents an ordered pair of values.

    Example:
        point : Pair Int Int
        point = Pair 3 4
-}
type Pair a b
    = Pair a b


-- =============================================================================
-- Numeric Protocol
-- =============================================================================

{-| Protocol for numeric types supporting basic arithmetic operations.

    Implementing types must provide:
    - (+)  : Addition
    - (-)  : Subtraction
    - (*)  : Multiplication
    - negate : Negation (unary minus)
-}
protocol Num a where
    (+) : a -> a -> a
    (-) : a -> a -> a
    (*) : a -> a -> a
    negate : a -> a

{-| Protocol for types supporting division operations. -}
protocol Fractional a where
    (/) : a -> a -> a


{-| Protocol for types supporting integer division and modulo. -}
protocol Integral a where
    (//) : a -> a -> a
    (%) : a -> a -> a


-- =============================================================================
-- Comparison Protocols
-- =============================================================================

{-| Protocol for types supporting equality comparison.

    Implementing types must provide:
    - (==) : Equality test
    - (/=) : Inequality test (default implementation provided if == is defined)
-}
protocol Eq a where
    (==) : a -> a -> Bool
    (/=) : a -> a -> Bool
    (/=) x y = Bool.not (x == y)


{-| Protocol for types supporting ordering comparison.

    Implementing types must provide all comparison operators.
    Typically, implementing `compare` is sufficient, but we expose
    individual operators for flexibility.
-}
protocol Ord a where
    (<) : a -> a -> Bool
    (<=) : a -> a -> Bool
    (>) : a -> a -> Bool
    (>=) : a -> a -> Bool

protocol Appendable a where
    (++) : a -> a -> a


-- =============================================================================
-- Comparison Protocols
-- =============================================================================

{-| Protocol for types that can be converted to a String representation.

    Implementing types must provide:
    - toString : Convert the value to a String
-}

protocol Show a where
    toString : a -> String

-- =============================================================================
-- Logical Operations (External FFI)
-- =============================================================================

{-| Logical AND. Returns True only if both arguments are True.

    True && True   == True
    True && False  == False
    False && _     == False  (short-circuits)
-}
(&&) : Bool -> Bool -> Bool
(&&) = Bool.and


{-| Logical OR. Returns True if either argument is True.

    True || _      == True  (short-circuits)
    False || True  == True
    False || False == False
-}
(||) : Bool -> Bool -> Bool
(||) = Bool.or


{-| Logical not. Inverts the boolean value.

    not True  == False
    not False == True
-}

not: Bool -> Bool
not = Bool.not

-- =============================================================================
-- Function Composition and Application
-- =============================================================================

{-| Forward function application (pipe operator).
    Passes the left argument to the function on the right.

    x |> f  ==  f x

    Example:
        [1, 2, 3]
            |> map ((+) 1)
            |> filter isEven
-}
@external "@vibe/runtime" "pipeForward"
(|>) : a -> (a -> b) -> b


{-| Backward function application.
    Applies the function on the left to the argument on the right.

    f <| x  ==  f x

    Example:
        println <| "Hello, " ++ name
-}
@external "@vibe/runtime" "pipeBackward"
(<|) : (a -> b) -> a -> b


{-| Forward function composition.
    Composes two functions, applying the first then the second.

    (f >> g) x  ==  g (f x)

    Example:
        addOne >> double  -- first adds 1, then doubles
-}
@external "@vibe/runtime" "composeForward"
(>>) : (a -> b) -> (b -> c) -> (a -> c)


{-| Backward function composition.
    Composes two functions, applying the second then the first.

    (g << f) x  ==  g (f x)

    Example:
        double << addOne  -- first adds 1, then doubles
-}
@external "@vibe/runtime" "composeBackward"
(<<) : (b -> c) -> (a -> b) -> (a -> c)


-- =============================================================================
-- List Operations
-- =============================================================================

{-| Cons operator. Prepends an element to a list.

    1 :: [2, 3]  ==  [1, 2, 3]
-}
@external "@vibe/runtime" "listAppend"
(::) : a -> List a -> List a

-- =============================================================================
-- Protocol Implementations
-- =============================================================================

implement Num Int where
    (+) = Int.add
    (-) = Int.sub
    (*) = Int.mul
    negate = Int.negate

implement Num Float where
    (+) = Float.add
    (-) = Float.sub
    (*) = Float.mul
    negate = Float.negate

implement Fractional Float where
    (/) = Float.div

implement Integral Int where
    (//) = Int.div
    (%) = Int.mod

implement Eq Int where
    (==) = Int.eq

implement Eq Float where
    (==) = Float.eq

implement Ord Int where
    (<) = Int.lt
    (<=) = Int.lte
    (>) = Int.gt
    (>=) = Int.gte

implement Ord Float where
    (<) = Float.lt
    (<=) = Float.lte
    (>) = Float.gt
    (>=) = Float.gte

implement Appendable (List a) where
    (++) = List.append

implement Appendable String where
    (++) = String.append

implement Show Int where
    toString = Int.toString

implement Show Float where
    toString = Float.toString

implement Show Bool where
    toString = Bool.toString

-- =============================================================================
-- Utility Functions
-- =============================================================================

{-| Identity function. Returns its argument unchanged.

    identity x  ==  x
-}
identity : a -> a
identity x = x


{-| Constant function. Always returns the first argument.

    always x y  ==  x
-}
always : a -> b -> a
always x _ = x


{-| Flip the arguments of a binary function.

    flip f x y  ==  f y x
-}
flip : (a -> b -> c) -> b -> a -> c
flip f x y = f y x


{-| Function application. Useful for avoiding parentheses.

    apply f x  ==  f x
-}
apply : (a -> b) -> a -> b
apply f x = f x